from OpenGL.GL import *from OpenGL.GLUT import *from OpenGL.GLU import *import mathdef draw_points(x, y):    glPointSize(1)    glBegin(GL_POINTS)    glColor3f(255, 255, 255)    glVertex2f(x, y)    glEnd()# Starting from heredef zoneCircleConvert(x, y, x0, y0):    draw_points(x + x0, y + y0)    draw_points(y + x0, x + y0)    draw_points(y + x0, -x + y0)    draw_points(x + x0, -y + y0)    draw_points(-x + x0, -y + y0)    draw_points(-y + x0, -x + y0)    draw_points(-y + x0, x + y0)    draw_points(-x + x0, y + y0)def midPoint(x0, y0, radius):    d = 1 - radius    x = 0    y = radius    zoneCircleConvert(x, y, x0, y0)    while x < y:        if d >= 0:            d = d + 2 * x - 2 * y + 5            x = x + 1            y = y - 1        else:            d = d + 2 * x + 3            x = x + 1        zoneCircleConvert(x, y, x0, y0)def find_zone(dx, dy):    if abs(dx) <= abs(dy):        if dx >= 0 and dy >= 0:            return 1        elif dx <= 0 and dy >= 0:            return 2        elif dx >= 0 and dy <= 0:            return 6        elif dx <= 0 and dy <= 0:            return 5    else:        if dx >= 0 and dy >= 0:            return 0        elif dx <= 0 and dy >= 0:            return 3        elif dx >= 0 and dy <= 0:            return 7        elif dx <= 0 and dy <= 0:            return 4def convert_to_zone0(z, x, y):    match z:        case 0:            return x, y        case 1:            return y, x        case 2:            return y, -x        case 3:            return -x, y        case 4:            return -x, -y        case 5:            return -y, -x        case 6:            return -y, x        case 7:            return x, -ydef convert_original(z, x, y):    match z:        case 0:            return x, y        case 1:            return y, x        case 2:            return -y, x        case 3:            return -x, y        case 4:            return -x, -y        case 5:            return -y, -x        case 6:            return y, -x        case 7:            return x, -ydef midpointline(x1, y1, x2, y2, z):    dx = x2 - x1    dy = y2 - y1    d = (2 * dy) - dx    e = 2 * dy    ne = 2 * (dy - dx)    x = x1    y = y1    while x < x2:        px, py = convert_original(z, x, y)        draw_points(px, py)        if d < 0:            x += 1            d += e        else:            x += 1            y += 1            d += nedef draw_lines(x1, y1, x2, y2):    dx = x2 - x1    dy = y2 - y1    zone = find_zone(dx, dy)    px1, py1 = convert_to_zone0(zone, x1, y1)    px2, py2 = convert_to_zone0(zone, x2, y2)    midpointline(px1, py1, px2, py2, zone)def eightWay(x, y, radius):    midPoint(x, y, radius)def draw_circle(radius):    eightWay(475, 475, radius)def draw_square(radius):    draw_lines(475 - radius, 475 + radius, 475 + radius, 475 + radius)    draw_lines(475 - radius, 475 - radius, 475 + radius, 475 - radius)    draw_lines(475 + radius, 475 + radius, 475 + radius, 475 - radius)    draw_lines(475 - radius, 475 + radius, 475 - radius, 475 - radius)def loop(n):    r = 100    for i in range(n+1):        draw_circle(r)        draw_square(r)        r += 50*in = int(input("Enter a number: "))# Screen Filesdef screen():    glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT)    glLoadIdentity()    glViewport(0, 0, 800, 800)    glMatrixMode(GL_PROJECTION)    glLoadIdentity()    glOrtho(0.0, 1000, -50.0, 1000, 0.0, 1.0)    glMatrixMode(GL_MODELVIEW)    glLoadIdentity()    loop(n)    glutSwapBuffers()glutInit()glutInitDisplayMode(GLUT_RGBA)glutInitWindowSize(768, 768)glutInitWindowPosition(0, 0)glutCreateWindow(b"Lab Assignment 3 - 20101298")glutDisplayFunc(screen)glutMainLoop()